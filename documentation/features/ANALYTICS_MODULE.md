## Analytics module

### Goals:
* Event-based model. Save as much as possible raw data.
* Never delete any data to be able to make retrospective research and compare the old values of an old algorithm
and the new values of the new calculation algorithm.
* Easy and quick access to the entity current stats values to show on the website pages.

### Solutions

#### Database architecture

There is a table entity_event_param which is used to store `statistics events.` Examples of such events:
* saving of the current entity parameter (current importance, current upvotes amount, etc.)
* calculation of the entity parameter (importance delta for current value and value before 24 hours, etc.)

Notes:
* There are no updates. Possible operations are inserts/selects.
* There is a relational database, same as the main database (PostgreSQL). It is not required yet to implement such solutions
as ClickHouse, because the required period of updating is `1 hour`.
* Statistics events are completely separated from `users activity` - a different kind of events, generated by the user.
Statistic event - an event only about some values.
* json_value field contains all stats values, related values, calculation description, the full formula, etc. This is about
the principle `as much information as possible.` In the future, it will be possible to analyze the effectiveness of different
calculation algorithms.
* There are `entity current params` tables, like `posts_current_params`. It has a one-to-one relation with the related entity
(`posts`). This is required to decrease the number of locks caused by frequent updates.

Scaling strategy:
* This table is placed to separate the database to move this database to a separate DB server in the future.
* Partitioning for `hot values` (required for calculation).
* Sharding for `cold values` (required for retrospective).
* Migration to ClickHouse using existing the DB schema.


#### Workers

Currently, there are CRON-like workers only. In the future, it is possible to use queue-like workers (event-based, not the schedule-based ones).

There are different kinds of workers:
* External data worker (ex. importance worker) - this worker fetches data from external sources (ex. blockchain) and saves data to the database, at most to `entity_event_params.` (But not always due to the existing legacy solutions)
* Internal data worker - this worker fetches data from internal sources (main relational database) and saves it to `entity_event_param.` Example - fetch current upvotes and save it.
* Worker-calculator - it uses only `entity_event_param` data to calculate new values. Example - calculate importance
delta.
* Worker-saver - it is used to save current entity stats values to concrete entity tables. For example, update (here update appears) current importance delta for the concrete post. To use this value to select posts, the lists are ordered by importance delta
(frontend application is a client for such request). Sometimes it is better to save such values by `worker-calculator` because it has all the required values.


#### Code implementation

**Goal**: it should be straightforward to add new parameters to stats.

**Main codebase solution:**
* The required parameter and related parameters are declared with the help of special objects with the appropriate Typescript interfaces.
Here is an [example for deltas calculations for posts](../../lib/stats/job-params/posts-job-params.ts)
* There are different classes-jobs to save current parameters ([example for posts](../../lib/stats/job/posts-stats-job.ts)).
In the future, these classes will be refactored to split declaration and implementation.

**Autotests codebase solution:**
* The before-after-delta parameters sets are generated randomly for every tested parameter. [Reference to generator](../../test/generators/entity/entity-event-param-generator-v2.ts)

* [StatsHelper](../../test/integration/helpers/stats-helper.ts) has a collection of an expected field structure separated from the main codebase - this is by design. It is required
to code the expected values before implementing the solution (TDD principle). If somebody occasionally changes the implementation, the autotest will fail.
* There is a universal `StatsHelper` parameters checker, based on `expected set` declared manually inside autotests.
* Here is [an example of the test suite for posts](../../test/integration/stats/stats-organizations.test.ts) 
